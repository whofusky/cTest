/*
说明：
    此头文件只包含 protocol104.cpp 中导出的外部调用接口
    此头文件从protocol104.h中分离出来@20180207111656
*/

#pragma once

#ifndef PRTCLINTRFCMDBS_H
#define PRTCLINTRFCMDBS_H





#ifdef _WIN32
    #ifndef WINDOWS_PLATFORM
        #define WINDOWS_PLATFORM
    #endif
#endif

#ifdef WIN64
    #ifndef WINDOWS_PLATFORM
        #define WINDOWS_PLATFORM
    #endif
#endif



//该宏完成Dll项目内部使用__declspec(dllexport)导出
//在DLL项目外部使用时，用__declspec(dllimport)导入
#ifdef DLL_IMPLEMENT
    #define DLL_API extern"C" __declspec(dllexport)
#else
    #define DLL_API extern"C" __declspec(dllimport)
#endif



#ifdef WINDOWS_PLATFORM
    #define EXPDLL DLL_API
#else
    #define EXPDLL
#endif




/*******************************************************************************
*功能：创建一个ADU对象。
*描述：调用C_ModbusADU类的构造函数声明一个ADU对象。
*输入：
*      cstmInfo_p   ： ADU数据帧的结构描述；
*      uType        ： 构造帧的类型，PDU或ADU；
*      allocFlag    ： 是否分配存储空间
*返回：
*      u_char*      : ADU对象
*
*******************************************************************************/
EXPDLL u_char* createAPDU ( APDU_DSCR* cstmInfo_p,
                            u_char duType,
                            u_char  allocFlag
                          );

/*******************************************************************************
*功能：释放一个ADU对象的空间。
*描述：调用C_ModbusADU类的析构函数释放一个ADU对象的空间。
*输入：
*      APDU_Obj_p   ： ADU对象；
*返回：
*      空
*
*******************************************************************************/
EXPDLL void freeAPDU ( u_char* APDU_Obj_p );

/*******************************************************************************
*功能：获取MODBUS的协议号。
*描述：协议号用来判断传输介质是网口还是串口,协议号为奇数时，
       表示使用网口；当协议号为偶数时，表示使用串口。
*输入：
*      空；
*返回：
*      固定值，0x69
*
*******************************************************************************/
EXPDLL int getPtclID();

/******************************************************************************
*功能：创建步规则。
*描述：创建步规则、设置默认的会话设置。
*输入：
*     srvNo      ：会话号，MODBUS只支持一种会话。
*     usingMode  : 模式码，固定为ONLY_ONE，即0
*输出 :
*      stnSnnCfg_p: 默认会话步、帧配置信息
*      ptclFunDsc : 默认会话步对应的cot,tid配置
*返回：
*      FUN_RL     ： 默认步规则
*
******************************************************************************/
EXPDLL FUN_RL* createRl_P ( u_char srvNo,
                            u_char usingMode,
                            T_snnCfg* stnSnnCfg_p,
                            T_ptclFunDsc* ptclFunDsc
                          );

/*******************************************************************************
 *功能 : 通过会话的步规则信息，构造功能码和数据域。
 *输入：
 *       stnSnnCfg_p：站会话配置，会话的通道信息块中保留存储地址；
 *       stepNo:步号
 *输出：
 *       stnSnnPara_p: 给定步号需要加载的点地址、时标和协议要求传
                       输且由存储保存的ADU其它类型元素值
 *
 *返回值：执行状态，=0成功，<0 失败
 *修改历史
 *
*******************************************************************************/
EXPDLL int getGLoadPnt ( T_snnCfg* stnSnnCfg_p,
                         u_char stepNo,
                         T_snnPara* stnSnnPara_p
                       );

/*******************************************************************************
 *功能 : 释放ONE_STEP对象空间
 *输入 : ONE_STEP对象指针
 *输出 : 无
 *返回 : 0 成功
 *修改历史
 *     采用104规约函数，无需改动
*******************************************************************************/
EXPDLL int freeOneStep ( ONE_STEP* pSpace );

/*******************************************************************************
 *功能 : 释放FUN_RL对象空间
 *输入 : FUN_RL对象指针
         T_snnCfg 对象指针
         T_ptclFunDsc 对象指针
 *输出 : 无
 *返回 : 0，成功
 *修改历史
 *      采用104规约函数，无需改动
*******************************************************************************/
EXPDLL int  freeRl_P ( FUN_RL* pSpace,
                       T_snnCfg* pSnnCfg,
                       T_ptclFunDsc* ptclFunDsc
                     );

/*******************************************************************************
  *功能：步驱动，设置起始帧对应的步（会话中的第一帧才调用）
  *输入：
  *      srvNo            ：功能码
  *      usingMode        :模式码
  *      preStepRul_p     ：当前功能步，其中reqPDU_Num为当前功能步已完成的帧编号
  *      statrtStepStnD_p :会话步需要的数据信息（详见此类型说明）
  *输出：
  *      preStepRul_p     :设置完成起始帧后对应的步信息
  *返回：
  *      =0               :接口没有逻辑直接返回
  *      >0               :会话状态
  *      0xffff           :该功能不支持
  *      <0               :接口异常
  *修改历史
  *
*******************************************************************************/
EXPDLL int startStep ( u_short ssnNo,
                       u_char usingNode,
                       ONE_STEP* preStepRul_p,
                       T_snnPara* statrtStepStnD_p
                     );

/*******************************************************************************
 *功能：步驱动，设置下一帧对应的步
 * 输入：
 *      Fun_p        ：步规则
 *      stepRl_p     ：当前帧对应的步
 *      funDsc_p     ：会话号与主动性
 *      ssnPar_p     ：会话步需要的数据信息（详见此类型说明）
 *输出：
 *      stepRl_p     ：下一帧对应的步
 *      nxtStepStat_p：会话状态
 *返回：
 *      >0           ：调用nxtStep发的这一帧数据的下一帧对应
                       的步号(如果已经是最后一步最后一帧则此
                       值为当前帧对应的步号）
 *      0xffff       ：该功能不支持
 *      <0           ：接口异常
 *修改历史
 *
*******************************************************************************/
EXPDLL int nxtStep ( FUN_RL* Fun_p,
                     ONE_STEP* stepRl_p,
                     T_ptclFunDsc* funDsc_p,
                     T_snnPara* ssnPar_p,
                     u_int* nxtStepStat_p
                   );

/*******************************************************************************
  *功能：解ASDU
  *     （104协议中：此接口设计是为了解析出TID_p和COT_p,后面的接口根据TID_p和COT_p
  *         得到会话号与会话的主被动性、会话步号）
  *（modbus协议中：此接口没有实际的意义，因为：只从帧的数据来看无法区分主被动和步号）
  *
  *输入：
  *     APDU_p  ：APDU地址
  *     APDU_lng: APDU长度
  *输出：
  *     TID     ：类型标识符
  *     COT     ：传输原因
  *返回：
  *     0       ：正确
  *     <0      ：错误
  *修改历史：
  *
*******************************************************************************/
EXPDLL int chkASDU ( u_char* APDU_p,
                     u_short APDU_lng,
                     u_int* TID_p,
                     u_int* COT_p
                   );

/*******************************************************************************
  *功能：获取可能的功能号
  *       (104协议中：此接口设计是为得到会话号与会话的主被动性)
  *（modbus协议中：此接口在modbus中没有实际的意义,因为：只从帧
  *        的数据来看无法区分主被动 主动被在站的开始时就确定了与104有区别)
  *
  *输入：
  *     TID：     类型标识符
  *     COT：     传输原因
  *输出：
  *     funDsc_p：会话号与主动性数组
  *     funNum_p：功能码个数（即funDsc_p数组实际下标值）
  *返回：
  *     协议编号：宏P_MODBUS_TCP
  *修改历史
  *
*******************************************************************************/
EXPDLL int getSsnSet ( u_int TID,
                       u_int COT,
                       T_ptclFunDsc* funDsc_p,
                       u_char* funNum_p
                     );


/*******************************************************************************
  *功能：获取会话步号（并绑定新的ASDU对象)
  *输入：
  *     funDsc_p  :会话号与主动性
  *     TID       :类型标识符
  *     COT       :传输原因
  *     PDUObj_p  :APDU104对象
  *     ASDU_p    :ASDU地址
  *     ASDUlng   :ASDU长度
  *输出：
  *     无
  *返回：
  *     < 0       :系统异常
  *     0xffff    :该功能不支持
  *     > 0       :stepNo步号
  *修改历史:
  *
*******************************************************************************/
EXPDLL int getFunStep ( T_ptclFunDsc* funDsc_p,
                        u_int TID,
                        u_int COT,
                        u_char* PDUObj_p,
                        u_char* ASDU_p,
                        u_short ASDUlng
                      );

/*******************************************************************************
  *功能 ：对会话步stepRl_p中的帧进行验收，验收后把帧数据赋于ssnPar_p
  * 输入：
  *     Fun_p        :步规则
  *     stepRl_p     :当前步
  *     funDsc_p     :会话号与主动性
  *输出：
  *     ssnPar_p     :详见此类型说明
  *     nxtStepNo_p  :下一帧的步号（最后一步的最后一帧时步号不变）
  *返回：
  *  0               :成功，
  *  0xffff          :该功能不支持
  *  负数            :失败
  *修改历史
  *
 ******************************************************************************/
EXPDLL int chkFun ( FUN_RL* Fun_p,
                    ONE_STEP* stepRl_p,
                    T_ptclFunDsc* funDsc_p,
                    T_snnPara* ssnPar_p,
                    u_int* nxtStepNo_p
                  );

/*******************************************************************************
  *功能 ：把PDU_p指针绑定到ONE_STEP对象上
  * 输入：
  *     stepRl_p  :绑定到的目标ONE_STEP
  *     funDsc_p  :主、被动 描述
  *     PDU_p     :被绑定的地址
  *     PDUlng    :绑定内存的长度
  *     duType    :绑定地址的类型
  *输出：
  *     无
  *返回：
  *     0         :成功，
  *     负数      :失败
  *修改：
  *
 ******************************************************************************/
EXPDLL int bindToMem ( ONE_STEP* stepRl_p,
                       T_ptclFunDsc* funDsc_p,
                       u_char* ASDU_p,
                       u_short ASDUlng,
                       u_char duType
                     );

/*******************************************************************************
  *功能 ：获得C_ModbusADU对象的ADU_p或PDU_p地址
  * 输入：
  *     apduObj_p :C_ModbusADU对象
  *     duType    :需要获取的类型（adu或pdu)
  *输出：
  *     apduLng   :ADU_p或PDU_p内存中内容的长度
  *返回：
  *     ADU_p或PDU_p地址
  *修改：
  *
 ******************************************************************************/
EXPDLL u_char* getDU ( u_char* apduObj_p,
                       u_short& apduLng,
                       char duType
                     );

/*******************************************************************************
*功能：MODBUS数据中的ADU_p或PDU_p内存中内容的长度。
*输入：
*      apduObj_p 对象指针
*输出：
*      无
*返回：
*      ADU_p或PDU_p内存中内容的长度
*修改历史：
*
*******************************************************************************/
EXPDLL u_short getDULng ( u_char* apduObj_p );

/*******************************************************************************
*功能：设置 ADU数据帧的结构描述
*输入：
*      apduObj_p ：C_ModbusADU对象指针
*      apduDSCR  ：ADU数据帧的结构描述
*输出：
*      无
*返回：
*      void
*修改历史：
*
*******************************************************************************/
EXPDLL void setAPDU_DSCR ( u_char* apduObj_p,
                           ADU_DSCR apduDSCR
                         );


/**************************传输控制*********************************************/

/*******************************************************************************
*功能：MODBUS数据中的帧头长度，即MBAP的长度。
*输入：
*      void；
*输出：
*      void；
*返回：
*      u_char
*修改历史：
*
*******************************************************************************/
EXPDLL u_char getHeaderlng();

/*******************************************************************************
*功能：只将MODBUS的ADU对象转换成字节流,并更新MBAP中“长度”域的值。
*描述：在MODBUS中，不同角色的站点，构造帧头的方式是不同的。主站需
*       要设置帧头的所有域，而子站只需要设置长度域，
*       而其他域则复制请求帧中的响应的段域。
*输入：
*      rtmParam_p   ： 空；
*      cfgParam_p   ： 空；
*      APDU104_p    ： MODBUS协议的ADU对象
*      ASDUFrm_Lng  :  PDU数据的长度
*输出：
*      APDU_buf_p   : ADU数据的字节流
*      APDU_bufLng  : 字节流的长度
*返回：
*      void
*修改历史：
*
*******************************************************************************/
EXPDLL void packAPDU ( void* rtmParam_p,
                       void* cfgParam_p,
                       u_char* ASDUFrm_p,
                       u_short ASDUFrm_Lng,
                       u_char* APDU_buf_p,
                       u_char& APDU_bufLng
                     );

/*******************************************************************************
*功能：检查接收的数据帧是否符合MODBUS数据帧的格式规范，暂时
*      只实现TCP帧，其他帧格式未考虑。
*输入：
*      rtmParam_p   ： 空；
*      cfgParam_p   ： 暂时为空；用于指定MODBUS帧的格式。
*      revDataFrm   ： 接收数据
*输出：
*      APDU_buf_p   : ADU数据的字节流
*      APDU_bufLng  : 字节流的长度
*返回：
*      void    ：ADU数据格式正确时，返回值的高8位表示帧类型，低8位为0；
*                ADU数据格式正确时，返回值的高8位表示将要处理的动作，
*                 低8位为错误代码；
*修改历史：
*
*******************************************************************************/
EXPDLL u_short chkAPDUData ( revBuf* revDataFrm,
                             void* rtmParam_p,
                             void* cfgParam_p
                           );

/*******************************************************************************
*功能：设置帧头MBAP中的“长度”域,并检查发送数据的条件是否就绪。
*      在MODBUS协议中，如果是客户端（请求数据端），
*      需要记忆功能，以便核对服务端发回的应答帧。发送数据前，MODBUS
*      检查是否可以将数据加入到存储链表中。
*      如果是服务端（响应数据），就不需要记忆功能，将数据发出即可。
*输入：
*      role        ： 站点角色；
*      rtmParam_p  ： 实时参数，比如MBAP帧头中的事物处理标识；
*      data_p      :  ADU数据
*      length      :  ADU数据长度
*输出：
*      void
*返回：
*      u_int       :  高16位返回函数执行的结果信息（错误信息）；
*                     高16位返回结果信息（错误信息）的解决方法
*注意事项：
*
*******************************************************************************/
EXPDLL u_int CheckSendState ( short role,
                              void* rtmParam_p,
                              u_char* data_p,
                              u_short length
                            );

/*******************************************************************************
*功能：检查接收数据帧的功能码和事物处理标识是否和本站发出的请求
*      帧一致。在MODBUS协议中，只有客户端（请求数据端），
*     才需要检查接收数据，而服务端（响应数据）就不需要检查数据。
*     上层构造数据时，直接复制帧头即可。
*输入：
*      role        ： 站点角色；
*      rtmParam_p  ： 实时参数，比如MBAP帧头中的事物处理标识；
*      data_p      :  ADU数据
*      length      :  ADU数据长度
*输出：
*      void
*返回：
*      u_int       :  高16位返回函数执行的结果信息（错误信息）；
*                     高16位返回结果信息（错误信息）的解决方法
*注意：
*
*******************************************************************************/
EXPDLL u_int CheckRecvState ( short role,
                              void* rtmParam_p,
                              u_char* data_p,
                              u_short length
                            );

/*******************************************************************************
*功能：更新发送端的实时参数，比如MBAP帧头中的事物处理标识, 即发送序号。
*输入：
*      role           ： 站点角色；
*      rtmParam_p     ： 实时参数，比如MBAP帧头中的事物处理标识；
*      cfgParam_p     ： 空
*      tmrCtrlCode_p  ： 空
*      data_p         :  ADU数据
*      length         :  ADU数据长度
*输出：
*      rtmParam_p
*返回：
*      u_int       :  是否需要发送侧协调，MODBUS不需要协调，因此都返回0
*修改历史：
*
*******************************************************************************/
EXPDLL u_short UpdateSendState ( short role,
                                 void* rtmParam_p,
                                 void* cfgParam_p,
                                 u_char* tmrCtrlCode_p,
                                 u_char* data_p,
                                 u_short length
                               );

/*******************************************************************************
* 功能：在MODBUS中，并不需要设置接收侧的参数，因此该函数没有使用。
* 描述：无
* 接口参数：
*     无
* 返回值：无
*******************************************************************************/
EXPDLL u_short UpdateRecvState ( short role,
                                 void* rtmParam_p,
                                 void* cfgParam_p,
                                 u_char* tmrCtrlCode_p,
                                 u_char* data_p,
                                 u_short length
                               );


/*******************************************************************************
* 功能：在MODBUS中，该函数没有使用。
* 描述：无
* 接口参数：
*     无
* 返回值：无
*******************************************************************************/
EXPDLL int getFrameType ( u_char* data_p,
                          u_short length
                        );

/*******************************************************************************
* 功能：在MODBUS中，并不需要底层与上层之间的异常情况的协调。
* 描述：无
* 接口参数：
*     无
* 返回值：无
*******************************************************************************/
EXPDLL int HandleRecvStateError ( transCtrlFrmDsc* ctrlFrm,
                                  void* rtmParam_p,
                                  int error
                                );


/*******************************************************************************
* 功能：在MODBUS中，并不需要底层控制帧应答发送数据。
* 描述：无
* 接口参数：
*     无
* 返回值：无
*******************************************************************************/
EXPDLL int RespCtrlFrame ( transCtrlFrmDsc* ctrlFrm,
                           void* rtmParam_p,
                           int result
                         );

/*******************************************************************************
* 功能：在MODBUS中，并不需要底层控制帧协调发送数据。
* 描述：无
* 接口参数：
*     无
* 返回值：无
*******************************************************************************/
EXPDLL int CtrlFrame ( transCtrlFrmDsc* ctrlFrm,
                       void* rtmParam_p,
                       int result
                     );

EXPDLL int APDUbindToMem ( u_char* apduObj_p,
                           u_char* APDU_p,
                           u_short ASDUlng,
                           u_char duType
                         );

/*******************************************************************************
  *功能：获取MODBUS数据帧的长度。计算方法如下：
  *     从Socket接收缓冲中，获取MBAP中“长度”域的值，
  *     然后再根据MBAP的长度，计算出ADU长度。
  * 输入：
  *      bufferAdd   ：MBAP首地址
  *      bufferLng   : MBAP长度
  *输出：
  *      无
  *返回：
  *    >0 成功返回ADU长度(MBAP+PDU)
  *    －1 缓冲区长度错误
  *    －2 首地址不是启动字符
  *    <0  接口执行异常
  *修改历史
  *
*******************************************************************************/
EXPDLL int getApduLngFrmBuf ( char*  bufferAdd,
                              int bufferLng
                            );




#endif